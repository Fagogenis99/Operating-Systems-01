# Operating-Systems-01
Konstantinos Fagogenis - sdi2100199

## Αναφορά Εργασίας Ανταλλαγής Μηνυμάτων με Κοινόχρηστη Μνήμη 


### Οδηγίες Χρήσης
Για να χρησιμοποιήσετε το πρόγραμμα, αρχικά μεταγλωττίστε τον κώδικα τρέχοντας make στο terminal, η οποία θα δημιουργήσει το εκτελέσιμο αρχείο message. Στη συνέχεια, εκτελέστε το πρόγραμμα δίνοντας ως όρισμα το ID του δωματίου που θέλετε να συνδεθείτε (π.χ. ./message 10). Έτσι ,μπορείτε να πληκτρολογείτε μηνύματα για να συνομιλείτε με άλλους χρήστες (σε άλλα terminals στα οποία έχετε τρέξει την ίδια εντολή, με το ίδιο id) στο ίδιο δωμάτιο διαλόγου, ενώ για να αποχωρήσετε πληκτρολογήστε τη λέξη "TERMINATE".

1. ### Εισαγωγή
Ο στόχος της εργασίας ήταν η σχεδίαση μιας εφαρμογής επικοινωνίας, μέσω ανταλλαγής μηνυμάτων 
σε πραγματικό χρόνο. Η εφαρμογή αυτή επιτρέπει σε πολλούς χρήστες να μπουν σε διαφορετικά
dialog rooms ταυτόχρονα αλλά και στο ίδιο.
Χρησιμοποιήθηκε κοινόχρηστη μνήμη (shared memory) για την αποθήκευση των μηνυμάτων και των 
στοιχείων των διαλόγων , έτσι ώστε να είναι προσβάσιμα από όλες τις διεργασίες. Αλλά και 
σηματοφόροι (semaphores) κατά την ανάγνωση και την εγγραφή δεδομένων και μηνυμάτων , για τον
συγχρονισμό των διεργασιών και την αποφυγή περιπλοκών.

2. ### Σχεδιασμός Δεδομένων
Η διαχείριση της μνήμης πραγματοποιήθηκε με την χρήση τριών βασικών δομών δεδομένων που 
υλοποιούνται στο αρχείο message.h: 
- struct Message: περιέχει το κείμενο του μηνύματος, το id του αποστολέα (sender_pid) και έναν μετρητή (readers_left) που δείχνει πόσοι χρήστες πρέπει ακόμα να διαβάσουν το μήνυμα πριν αυτό διαγραφεί. Περιέχει επίσης ένα flag (is_free) για το αν η θέση του μηνύματος είναι διαθέσιμη αλλά και τα id του διαλόγου στου οποίου ανήκει και του ίδιου του μηνύματος.
- struct Dialog: περιέχει πληροφορίες για κάθε δωμάτιο διαλόγου όπως το id του, τον αριθμό των συνδεδεμένων χρηστών (user_count), ένα flag (is_free) για αν το δωμάτιο είναι διαθέσιμο και το latest_message_id για την τοπική αρίθμηση των μηνυμάτων.
- struct SharedMemory: περιέχει τον αριθμό των συνολικών χρηστών στο σύστημα ,τον πίνακα με τα μηνύματα και τον πίνακα με τους διάλογους.

3. ### Σχεδιασμός Διεργασιών (forking)
Η κύρια διεργασία κατά την εκκίνηση καλεί την fork() για να διαχωριστεί σε 2 τμήματα. Την 
διεργασία γονέας/writer, όπου αναλαμβάνει την μεταφορά των μηνυμάτων από τον χρήστη και 
την εγγραφή τους στην κοινόχρηστη μνήμη. Ενώ η διεργασία παιδί/reader αναλαμβάνει την 
παρακολούθηση της κοινόχρηστης μνήμης για νέα μηνύματα (τα οποία δεν έχει ήδη διαβάσει)
και την εμφάνισή τους στην οθόνη.

Αυτό μας επιτρέπει την ασύγχρονη λειτουργία, δηλαδή ο χρήστης να μπορεί να πληκτρολογεί 
ενώ ταυτόχρονα λαμβάνει μηνύματα.

4. ### Λεπτομέρειες Υλοποίησης
Η δημιουργία και διαχείριση της μνήμης γίνεται με τις κλήσεις συστήματος shmget και shmat. Ο πρώτος χρήστης που τρέχει την εφαρμογή ,ανιχνεύεται μέσω if(shm_nattch==1), αναλαμβάνει την αρχικοποίηση της μνήμης.

Όταν ο τελευταίος χρήστης αποχωρεί από ένα δωμάτιο, το δωμάτιο γίνεται ελεύθερο (is_free=1) και ο μετρητής μηνυμάτων μηδενίζεται, έτσι ώστε να μπορεί να επαναχρησιμοποιηθεί.

5. ### Βασικές Δυσκολίες και Εμπόδια
- Η ταυτόχρονη προσπάθεια πολλών χρηστών να γράψουν ή να δεσμεύσουν πόρους μπορεί να 
οδηγούσε σε αλλοίωση των δεδομένων ,για αυτό χρησιμοποιήθηκε ένας δυαδικός σηματοφόρος, 
πριν από οποιαδήποτε πρόσβαση στην κοινόχρηστη μνήμη οι διεργασίες καλούν την semop με 
λειτουργία κλειδώματος και την απελευθερώνουν αμέσως μετά την κρίσιμη περιοχή.

- Η χρήση ενός global μετρητή μηνυμάτων για όλα τα δωμάτια διαλόγων δημιουργούσε προβλήματα στη σειρά εμφάνισης. Για αυτό μετακινήθηκε ο μετρητής latest_message_id μέσα στη δομή Dialog. Έτσι κάθε δωμάτιο διατηρεί τη δική του ανεξάρτητη σειρά μηνυμάτων.

- Όταν ο χρήστης πληκτρολογούσε "TERMINATE", η διεργασία παιδί τερμάτιζε βίαια τον γονέα (SIGKILL), προκαλώντας μήνυμα σφάλματος "Killed".  Για αυτό προστέθηκε λογική ελέγχου ώστε το παιδί να στέλνει σήμα τερματισμού στον γονέα μόνο αν η εντολή "TERMINATE" προήλθε από άλλον χρήστη. Αν ο ίδιος ο χρήστης έδωσε την εντολή, το παιδί τερματίζει ομαλά (exit(0)), επιτρέποντας στον γονέα να ολοκληρώσει την wait().

